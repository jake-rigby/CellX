<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 mouseDown="onCanvasMouseDown(event)" 
		 mouseUp="onCanvasMouseUp(event)"
		 click="onCanvasClick(event)" 
		 enterFrame="onEnterFrame(event)"
		 rightClick="{isEditing = false}"
		 rollOut="onCanvasRollOut(event)" >
	
	<fx:Metadata>
		[Event(name="isCalibrationChange", type="flash.events.Event")]
	</fx:Metadata>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			
			public static const IS_CALIBRATION_CHANGE:String = "isCalibrationChange";
			
			private var points:Vector.<Point> = new Vector.<Point>();
			private var hoverPoint:int = -1;
			private var pointEditMode:Boolean = false;
			
			[Bindable] public var calibrationVO:CaptureVO;
			[Bindable] public var isEditing:Boolean = false;
			[Bindable] public var vo:CaptureVO;
			[Bindable] public var isCalibration:Boolean = false;
		
				
			public function set data(vo:CaptureVO):void
			{
				this.vo = vo;
				bi.source = vo.bmd;
				points = vo.points;
			}
			
			public function get requestedCalibrationState():Boolean
			{
				return isCalibrationCheck.selected;
			}
			
			private function onEnterFrame(event:Event):void
			{
				draw();
			}
			
			private function draw():void
			{
				var mpt:Point = new Point(canvas.mouseX, canvas.mouseY);
				canvas.graphics.clear();
				
				if (!pointEditMode) hoverPoint = -1;
				for (var i:int = 0; i < points.length; i++) {

					if (pointEditMode && i == hoverPoint) {
						
						points[i].x = canvas.mouseX;
						points[i].y = canvas.mouseY;
					}

					// line from last point to this one
					if (i > 0) {
						canvas.graphics.lineStyle(1, 0x0000ff);
						canvas.graphics.moveTo(points[i-1].x, points[i-1].y);
						canvas.graphics.lineTo(points[i].x, points[i].y);
					}
					
					// this point
					if (mpt.subtract(points[i]).length <= 8 && !pointEditMode) {
						hoverPoint = i;
						canvas.graphics.lineStyle(1,0xff0000);
					}
					else canvas.graphics.lineStyle(1,0xffff00);
					canvas.graphics.drawCircle(points[i].x, points[i].y, 8);
				}
				
				if (isEditing && i && i > -1 && hoverPoint < 0 && !pointEditMode) {
					canvas.graphics.moveTo(points[i-1].x, points[i-1].y);					
					canvas.graphics.lineTo(canvas.mouseX, canvas.mouseY);
				}
				
				dbg.text = String(hoverPoint);
			}
			
			protected function onCanvasMouseDown(evt:MouseEvent):void
			{
				if (hoverPoint > -1) pointEditMode = true;
				else {
					// find the closest line to the click point, if below snap threshold, add another point there
					for (var i:int = 1; i < points.length; i++) {
						
						var m:Number = ( points[i].x - points[i-1].x ) / ( points[i].y - points[i-1].y ),
							b:Number = points[i].y - ( m * points[i].x ),
							d:Number = Math.abs( evt.localY - ( m * evt.localX ) - b ) / Math.sqrt( (m*m) + 1);
						
						if (d < 10) break;
					}
					
					if (i < points.length) {
						
						points.splice(i, 0, new Point(evt.localX, evt.localY));
						return;
					}
					
					// add a point if we got here
					if (!isEditing) isEditing = true;
					else points.push(new Point(evt.localX, evt.localY));
					draw();
					
				}
			}
										
			protected function onCanvasMouseUp(evt:MouseEvent):void
			{
				pointEditMode = false;
			}
			
			protected function onCanvasRollOut(evt:MouseEvent):void
			{
				if (pointEditMode) {
					points.splice(hoverPoint,1);
					pointEditMode = false;
				}
				isEditing = false;
			}
			
			protected function onCanvasClick(event:MouseEvent):void
			{
			}

			
			protected function onChangeCalibration(event:Event):void
			{
				dispatchEvent(new Event(IS_CALIBRATION_CHANGE));
				if (isCalibrationCheck.selected) {
					calibrationVO = vo;
				} else if (calibrationVO == vo) {
					calibrationVO = null;
				}
			}
			
		]]>
	</fx:Script>
	
	<s:BitmapImage width="100%" height="100%" id="bi"/>
	<mx:UIComponent id="canvas" width="100%" height="100%" />
	
	<s:HGroup top="5" right="5" verticalAlign="bottom">
		<s:TextInput id="calibInput" visible="{calibrationVO == vo}" />
		<s:CheckBox id="isCalibrationCheck" selected="{calibrationVO == vo}" change="onChangeCalibration(event)" 
					click="{event.stopPropagation()}"/>
		<s:Label color="white" text="use as calibration" />
		<s:Label color="red" id="dbg" />
	</s:HGroup>
	
</s:Group>
